<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>QR Code Secret Decoder</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2em; }
        #result { margin-top: 1em; font-weight: bold; }
        #secrets { margin-top: 1em; font-weight: bold; }
        #info { margin-top: 2em; margin-bottom: 2em; font-size: 90%; }
        .url-item { margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; }
        .secret-item { margin: 5px 0; padding: 8px; background: #e8f4fd; border-radius: 3px; font-family: monospace; }
        .secret-item { margin: 5px 0; padding: 8px; background: #e8f4fd; border-radius: 3px; font-family: monospace; }
        /* GitHub-style header/footer */
        .gh-header {
            background: #24292f;
            color: #fff;
            padding: 18px 32px;
            display: flex;
            align-items: center;
            border-radius: 8px 8px 0 0;
            margin: -2em -2em 2em -2em;
        }
        .gh-header svg {
            margin-right: 12px;
        }
        .gh-header-title {
            font-size: 1.5em;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .gh-footer {
            background: #f6f8fa;
            color: #586069;
            padding: 16px 32px;
            text-align: center;
            border-radius: 0 0 8px 8px;
            font-size: 0.95em;
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            z-index: 100;
            margin: 0;
        }
        .gh-footer a { color: #0366d6; text-decoration: none; }
        .gh-footer a:hover { text-decoration: underline; }
        @keyframes gh-spin {
            100% { transform: rotate(360deg); }
        }
        #spinner svg {
            display: inline-block;
            animation: gh-spin 1s linear infinite;
        }
    </style>
</head>
<body>
    <div class="gh-header">
        <svg height="32" viewBox="0 0 16 16" width="32" aria-hidden="true" fill="#fff"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.01.08-2.1 0 0 .67-.21 2.2.82a7.65 7.65 0 0 1 2-.27c.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.09.16 1.9.08 2.1.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.19 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
        <span class="gh-header-title">QR Code Secret Decoder</span>
    </div>
    <h2>Upload an QR-Code Image<br/><font size="-1">to decode the required OTP-Secret to be used with Home Assistant SENEC Integration</font></h2>
    <div id="info">This webpage will <b>not store</b> any data you upload, it will only decode the QR code and display the results in your browser.</div>
    <input type="file" id="fileInput" accept="image/*">
    <div id="spinner" style="display:none;text-align:center;margin:2em 0;">
        <svg width="48" height="48" viewBox="0 0 50 50" style="animation: gh-spin 1s linear infinite;">
            <circle cx="25" cy="25" r="20" fill="none" stroke="#0366d6" stroke-width="5" stroke-linecap="round" stroke-dasharray="31.4 31.4"/>
        </svg>
        <div style="color:#586069;">Processing QR code...</div>
    </div>
    <div id="result"></div>
    <div id="secrets"></div>
    <canvas id="canvas" style="display:none;"></canvas>

    <script src="jsQR.js"></script>
    <script>
    // Base32 encoding function
    function base32Encode(buffer) {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
        let bits = 0;
        let value = 0;
        let output = '';

        for (let i = 0; i < buffer.length; i++) {
            value = (value << 8) | buffer[i];
            bits += 8;

            while (bits >= 5) {
                output += alphabet[(value >>> (bits - 5)) & 31];
                bits -= 5;
            }
        }

        if (bits > 0) {
            output += alphabet[(value << (5 - bits)) & 31];
        }

        return output;
    }

    // Simple protobuf decoder for otpauth migration
    function decodeOtpauthMigration(data) {
        try {
            const buffer = new Uint8Array(atob(data).split('').map(c => c.charCodeAt(0)));
            const otpParams = [];
            let pos = 0;

            while (pos < buffer.length) {
                const tag = buffer[pos++];
                const fieldNumber = tag >> 3;
                const wireType = tag & 7;

                if (fieldNumber === 1 && wireType === 2) { // OTP parameters
                    const length = buffer[pos++];
                    const paramData = buffer.slice(pos, pos + length);
                    pos += length;

                    const param = parseOtpParam(paramData);
                    if (param) otpParams.push(param);
                }
            }

            return otpParams;
        } catch (e) {
            console.error('Decode error:', e);
            return [];
        }
    }

    function parseOtpParam(data) {
        const param = {};
        let pos = 0;

        while (pos < data.length) {
            const tag = data[pos++];
            const fieldNumber = tag >> 3;
            const wireType = tag & 7;

            if (wireType === 2) { // String/bytes
                const length = data[pos++];
                const value = data.slice(pos, pos + length);
                pos += length;

                switch (fieldNumber) {
                    case 1: // secret
                        param.secret = base32Encode(value);
                        break;
                    case 2: // name
                        param.name = new TextDecoder().decode(value);
                        break;
                    case 3: // issuer
                        param.issuer = new TextDecoder().decode(value);
                        break;
                }
            } else if (wireType === 0) { // Varint
                let value = 0;
                let shift = 0;
                while (pos < data.length && (data[pos] & 0x80)) {
                    value |= (data[pos++] & 0x7f) << shift;
                    shift += 7;
                }
                if (pos < data.length) {
                    value |= data[pos++] << shift;
                }

                switch (fieldNumber) {
                    case 4: // algorithm
                        param.algorithm = value;
                        break;
                    case 5: // digits
                        param.digits = value;
                        break;
                    case 6: // type
                        param.type = value;
                        break;
                }
            }
        }

        return param;
    }

    // Function to parse a regular otpauth URL
    function parseOtpauthUrl(otpauthUrl) {
        try {
            const url = new URL(otpauthUrl);
            const pathParts = url.pathname.split('/');
            const name = pathParts.length > 1 ? decodeURIComponent(pathParts[1]) : '';

            const params = new URLSearchParams(url.search);

            return {
                name: name,
                issuer: params.get('issuer') || '',
                secret: params.get('secret') || '',
                algorithm: params.get('algorithm') || 'SHA1',
                digits: params.get('digits') || '6',
                type: url.hostname // 'totp' or 'hotp'
            };
        } catch (e) {
            console.error('Error parsing otpauth URL:', e);
            return null;
        }
    }

    // Function to format secret with spaces every 4 characters
    function formatSecret(secret) {
        return secret.replace(/(.{4})/g, '$1 ').trim();
    }

    function buildOtpauthUrl(param) {
        const algorithms = { 1: 'SHA1', 2: 'SHA256', 3: 'SHA512', 4: 'MD5' };
        const types = { 1: 'hotp', 2: 'totp' };
        const digitCounts = { 1: '6', 2: '8' };

        const type = types[param.type] || 'totp';
        const name = encodeURIComponent(param.name || '');

        const params = new URLSearchParams();
        if (param.secret) params.set('secret', param.secret);
        if (param.issuer) params.set('issuer', param.issuer);
        if (param.algorithm) params.set('algorithm', algorithms[param.algorithm] || 'SHA1');
        if (param.digits) params.set('digits', digitCounts[param.digits] || '6');

        return `otpauth://${type}/${name}?${params.toString()}`;
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        document.getElementById('spinner').style.display = 'block';
        document.getElementById('result').textContent = '';
        document.getElementById('secrets').textContent = '';

        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.getElementById('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, canvas.width, canvas.height);

                document.getElementById('spinner').style.display = 'none';

                if (code) {
                    const qrData = code.data;

                    if (qrData.startsWith('otpauth-migration://')) {
                        try {
                            const url = new URL(qrData);
                            const data = url.searchParams.get('data');

                            if (data) {
                                const otpParams = decodeOtpauthMigration(data);

                                if (otpParams.length > 0) {
                                    let html = '<h3>Decoded OTP Information:</h3>';
                                    let secretsHtml = '<h3>Your OTP-Secrets (that you need to copy into the HA Integration configuration):</h3>';

                                    otpParams.forEach((param, index) => {
                                        const otpauthUrl = buildOtpauthUrl(param);
                                        html += `<div class="url-item">
                                            <strong>Account ${index + 1}:</strong> ${param.name || 'Unknown'}<br>
                                            <strong>Issuer:</strong> ${param.issuer || 'Unknown'}<br>
                                            <strong>URL:</strong> <code>${otpauthUrl}</code>
                                        </div>`;

                                        if (param.secret) {
                                            const formattedSecret = formatSecret(param.secret);
                                            secretsHtml += `<div class="secret-item">For '<strong>${param.name || 'Account 1'}</strong>' copy:<br/><br/>${formattedSecret}</div>`;
                                        }
                                    });

                                    document.getElementById('result').innerHTML = html;
                                    document.getElementById('secrets').innerHTML = secretsHtml;
                                } else {
                                    document.getElementById('result').textContent = 'No OTP parameters found in migration data.';
                                    document.getElementById('secrets').textContent = '';
                                }
                            } else {
                                document.getElementById('result').textContent = 'No data parameter found in migration URL.';
                                document.getElementById('secrets').textContent = '';
                            }
                        } catch (err) {
                            document.getElementById('result').textContent = 'Error decoding migration: ' + err.message;
                            document.getElementById('secrets').textContent = '';
                        }
                    } else if (qrData.startsWith('otpauth://')) {
                        try {
                            const param = parseOtpauthUrl(qrData);

                            if (param) {
                                let html = '<h3>Decoded OTP Information:</h3>';
                                let secretsHtml = '<h3>Your OTP-Secrets (that you need to copy into the HA Integration configuration):</h3>';

                                html += `<div class="url-item">
                                    <strong>Account 1:</strong> ${param.name || 'Unknown'}<br>
                                    <strong>Issuer:</strong> ${param.issuer || 'Unknown'}<br>
                                    <strong>URL:</strong> <code>${qrData}</code>
                                </div>`;

                                if (param.secret) {
                                    const formattedSecret = formatSecret(param.secret);
                                    secretsHtml += `<div class="secret-item">For '<strong>${param.name || 'Account 1'}</strong>' copy:<br/><br/>${formattedSecret}</div>`;
                                }

                                document.getElementById('result').innerHTML = html;
                                document.getElementById('secrets').innerHTML = secretsHtml;
                            } else {
                                document.getElementById('result').textContent = 'Error parsing otpauth URL.';
                                document.getElementById('secrets').textContent = '';
                            }
                        } catch (err) {
                            document.getElementById('result').textContent = 'Error parsing otpauth URL: ' + err.message;
                            document.getElementById('secrets').textContent = '';
                        }
                    } else {
                        document.getElementById('result').textContent = 'Secret: ' + qrData;
                        document.getElementById('secrets').textContent = '';
                    }
                } else {
                    document.getElementById('result').textContent = 'No QR code found in the image.';
                    document.getElementById('secrets').textContent = '';
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });
    </script>
    <div class="gh-footer">
        <span>Made with <span style="color:#ea4aaa;">&#10084;</span> for the <a href="https://github.com/marq24/ha-senec-v3/blob/master/docs/SENEC_OTP_SETUP.md" target="_blank">ha-senec-v3</a> project. Not affiliated with GitHub.</span>
    </div>
</body>
</html>
